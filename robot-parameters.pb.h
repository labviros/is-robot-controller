// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: robot-parameters.proto

#ifndef PROTOBUF_robot_2dparameters_2eproto__INCLUDED
#define PROTOBUF_robot_2dparameters_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_robot_2dparameters_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[2];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsFenceImpl();
void InitDefaultsFence();
void InitDefaultsParametersImpl();
void InitDefaultsParameters();
inline void InitDefaults() {
  InitDefaultsFence();
  InitDefaultsParameters();
}
}  // namespace protobuf_robot_2dparameters_2eproto
namespace is {
namespace robot {
class Fence;
class FenceDefaultTypeInternal;
extern FenceDefaultTypeInternal _Fence_default_instance_;
class Parameters;
class ParametersDefaultTypeInternal;
extern ParametersDefaultTypeInternal _Parameters_default_instance_;
}  // namespace robot
}  // namespace is
namespace is {
namespace robot {

// ===================================================================

class Fence : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:is.robot.Fence) */ {
 public:
  Fence();
  virtual ~Fence();

  Fence(const Fence& from);

  inline Fence& operator=(const Fence& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Fence(Fence&& from) noexcept
    : Fence() {
    *this = ::std::move(from);
  }

  inline Fence& operator=(Fence&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Fence& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Fence* internal_default_instance() {
    return reinterpret_cast<const Fence*>(
               &_Fence_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Fence* other);
  friend void swap(Fence& a, Fence& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Fence* New() const PROTOBUF_FINAL { return New(NULL); }

  Fence* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Fence& from);
  void MergeFrom(const Fence& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Fence* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float x_min = 1;
  void clear_x_min();
  static const int kXMinFieldNumber = 1;
  float x_min() const;
  void set_x_min(float value);

  // float x_max = 2;
  void clear_x_max();
  static const int kXMaxFieldNumber = 2;
  float x_max() const;
  void set_x_max(float value);

  // float y_min = 3;
  void clear_y_min();
  static const int kYMinFieldNumber = 3;
  float y_min() const;
  void set_y_min(float value);

  // float y_max = 4;
  void clear_y_max();
  static const int kYMaxFieldNumber = 4;
  float y_max() const;
  void set_y_max(float value);

  // @@protoc_insertion_point(class_scope:is.robot.Fence)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float x_min_;
  float x_max_;
  float y_min_;
  float y_max_;
  mutable int _cached_size_;
  friend struct ::protobuf_robot_2dparameters_2eproto::TableStruct;
  friend void ::protobuf_robot_2dparameters_2eproto::InitDefaultsFenceImpl();
};
// -------------------------------------------------------------------

class Parameters : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:is.robot.Parameters) */ {
 public:
  Parameters();
  virtual ~Parameters();

  Parameters(const Parameters& from);

  inline Parameters& operator=(const Parameters& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Parameters(Parameters&& from) noexcept
    : Parameters() {
    *this = ::std::move(from);
  }

  inline Parameters& operator=(Parameters&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Parameters& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Parameters* internal_default_instance() {
    return reinterpret_cast<const Parameters*>(
               &_Parameters_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Parameters* other);
  friend void swap(Parameters& a, Parameters& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Parameters* New() const PROTOBUF_FINAL { return New(NULL); }

  Parameters* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Parameters& from);
  void MergeFrom(const Parameters& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Parameters* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float speed_limits = 2;
  int speed_limits_size() const;
  void clear_speed_limits();
  static const int kSpeedLimitsFieldNumber = 2;
  float speed_limits(int index) const;
  void set_speed_limits(int index, float value);
  void add_speed_limits(float value);
  const ::google::protobuf::RepeatedField< float >&
      speed_limits() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_speed_limits();

  // repeated float gains = 3;
  int gains_size() const;
  void clear_gains();
  static const int kGainsFieldNumber = 3;
  float gains(int index) const;
  void set_gains(int index, float value);
  void add_gains(float value);
  const ::google::protobuf::RepeatedField< float >&
      gains() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_gains();

  // .is.robot.Fence fence = 4;
  bool has_fence() const;
  void clear_fence();
  static const int kFenceFieldNumber = 4;
  const ::is::robot::Fence& fence() const;
  ::is::robot::Fence* release_fence();
  ::is::robot::Fence* mutable_fence();
  void set_allocated_fence(::is::robot::Fence* fence);

  // float center_offset = 1;
  void clear_center_offset();
  static const int kCenterOffsetFieldNumber = 1;
  float center_offset() const;
  void set_center_offset(float value);

  // @@protoc_insertion_point(class_scope:is.robot.Parameters)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< float > speed_limits_;
  mutable int _speed_limits_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > gains_;
  mutable int _gains_cached_byte_size_;
  ::is::robot::Fence* fence_;
  float center_offset_;
  mutable int _cached_size_;
  friend struct ::protobuf_robot_2dparameters_2eproto::TableStruct;
  friend void ::protobuf_robot_2dparameters_2eproto::InitDefaultsParametersImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Fence

// float x_min = 1;
inline void Fence::clear_x_min() {
  x_min_ = 0;
}
inline float Fence::x_min() const {
  // @@protoc_insertion_point(field_get:is.robot.Fence.x_min)
  return x_min_;
}
inline void Fence::set_x_min(float value) {
  
  x_min_ = value;
  // @@protoc_insertion_point(field_set:is.robot.Fence.x_min)
}

// float x_max = 2;
inline void Fence::clear_x_max() {
  x_max_ = 0;
}
inline float Fence::x_max() const {
  // @@protoc_insertion_point(field_get:is.robot.Fence.x_max)
  return x_max_;
}
inline void Fence::set_x_max(float value) {
  
  x_max_ = value;
  // @@protoc_insertion_point(field_set:is.robot.Fence.x_max)
}

// float y_min = 3;
inline void Fence::clear_y_min() {
  y_min_ = 0;
}
inline float Fence::y_min() const {
  // @@protoc_insertion_point(field_get:is.robot.Fence.y_min)
  return y_min_;
}
inline void Fence::set_y_min(float value) {
  
  y_min_ = value;
  // @@protoc_insertion_point(field_set:is.robot.Fence.y_min)
}

// float y_max = 4;
inline void Fence::clear_y_max() {
  y_max_ = 0;
}
inline float Fence::y_max() const {
  // @@protoc_insertion_point(field_get:is.robot.Fence.y_max)
  return y_max_;
}
inline void Fence::set_y_max(float value) {
  
  y_max_ = value;
  // @@protoc_insertion_point(field_set:is.robot.Fence.y_max)
}

// -------------------------------------------------------------------

// Parameters

// float center_offset = 1;
inline void Parameters::clear_center_offset() {
  center_offset_ = 0;
}
inline float Parameters::center_offset() const {
  // @@protoc_insertion_point(field_get:is.robot.Parameters.center_offset)
  return center_offset_;
}
inline void Parameters::set_center_offset(float value) {
  
  center_offset_ = value;
  // @@protoc_insertion_point(field_set:is.robot.Parameters.center_offset)
}

// repeated float speed_limits = 2;
inline int Parameters::speed_limits_size() const {
  return speed_limits_.size();
}
inline void Parameters::clear_speed_limits() {
  speed_limits_.Clear();
}
inline float Parameters::speed_limits(int index) const {
  // @@protoc_insertion_point(field_get:is.robot.Parameters.speed_limits)
  return speed_limits_.Get(index);
}
inline void Parameters::set_speed_limits(int index, float value) {
  speed_limits_.Set(index, value);
  // @@protoc_insertion_point(field_set:is.robot.Parameters.speed_limits)
}
inline void Parameters::add_speed_limits(float value) {
  speed_limits_.Add(value);
  // @@protoc_insertion_point(field_add:is.robot.Parameters.speed_limits)
}
inline const ::google::protobuf::RepeatedField< float >&
Parameters::speed_limits() const {
  // @@protoc_insertion_point(field_list:is.robot.Parameters.speed_limits)
  return speed_limits_;
}
inline ::google::protobuf::RepeatedField< float >*
Parameters::mutable_speed_limits() {
  // @@protoc_insertion_point(field_mutable_list:is.robot.Parameters.speed_limits)
  return &speed_limits_;
}

// repeated float gains = 3;
inline int Parameters::gains_size() const {
  return gains_.size();
}
inline void Parameters::clear_gains() {
  gains_.Clear();
}
inline float Parameters::gains(int index) const {
  // @@protoc_insertion_point(field_get:is.robot.Parameters.gains)
  return gains_.Get(index);
}
inline void Parameters::set_gains(int index, float value) {
  gains_.Set(index, value);
  // @@protoc_insertion_point(field_set:is.robot.Parameters.gains)
}
inline void Parameters::add_gains(float value) {
  gains_.Add(value);
  // @@protoc_insertion_point(field_add:is.robot.Parameters.gains)
}
inline const ::google::protobuf::RepeatedField< float >&
Parameters::gains() const {
  // @@protoc_insertion_point(field_list:is.robot.Parameters.gains)
  return gains_;
}
inline ::google::protobuf::RepeatedField< float >*
Parameters::mutable_gains() {
  // @@protoc_insertion_point(field_mutable_list:is.robot.Parameters.gains)
  return &gains_;
}

// .is.robot.Fence fence = 4;
inline bool Parameters::has_fence() const {
  return this != internal_default_instance() && fence_ != NULL;
}
inline void Parameters::clear_fence() {
  if (GetArenaNoVirtual() == NULL && fence_ != NULL) {
    delete fence_;
  }
  fence_ = NULL;
}
inline const ::is::robot::Fence& Parameters::fence() const {
  const ::is::robot::Fence* p = fence_;
  // @@protoc_insertion_point(field_get:is.robot.Parameters.fence)
  return p != NULL ? *p : *reinterpret_cast<const ::is::robot::Fence*>(
      &::is::robot::_Fence_default_instance_);
}
inline ::is::robot::Fence* Parameters::release_fence() {
  // @@protoc_insertion_point(field_release:is.robot.Parameters.fence)
  
  ::is::robot::Fence* temp = fence_;
  fence_ = NULL;
  return temp;
}
inline ::is::robot::Fence* Parameters::mutable_fence() {
  
  if (fence_ == NULL) {
    fence_ = new ::is::robot::Fence;
  }
  // @@protoc_insertion_point(field_mutable:is.robot.Parameters.fence)
  return fence_;
}
inline void Parameters::set_allocated_fence(::is::robot::Fence* fence) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete fence_;
  }
  if (fence) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      fence = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, fence, submessage_arena);
    }
    
  } else {
    
  }
  fence_ = fence;
  // @@protoc_insertion_point(field_set_allocated:is.robot.Parameters.fence)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace robot
}  // namespace is

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_robot_2dparameters_2eproto__INCLUDED
